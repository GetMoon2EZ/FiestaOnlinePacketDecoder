import os
import __main__
import json
import re

INDENT = " " * 4

def const_format(string):
    string = string \
        .replace('.', '_') \
        .replace('-', '_') \
        .replace('\'', '') \
        .replace('"', '') \
        .replace('%', '') \
        .replace('?', '') \
        .replace('!', '') \
        .replace('Ã±', 'n') \
        .replace('#', '') \
        .replace('[', '') \
        .replace(']', '') \
        .replace('(', '') \
        .replace(')', '') \
        .replace('{', '') \
        .replace('}', '') \
        .replace(',', '') \
        .upper()

    return re.sub(' +', '_', string)

def cleanup_string(string):
    return string \
        .replace('Ã±', 'n') \
        .replace('"', '\\"') \
        .replace('%', '%%') \
        .replace('?', '')

class HFileGenerator:
    includes = []
    enums = []
    arrays = []
    path = ""
    filename = ""

    def __init__(self, path, filename) -> None:
        self.path = path
        self.filename = filename

    def add_include(self, include_file):
        self.includes.append(include_file)

    def add_enum(self, list):
        """ Add an enum to the H file
        @param list List of enum constant names
        """
        self.enums.append(list)

    def add_array(self, dict, type, name):
        """ Add a const array to the H file
        @param dict Dictionary with keys going from 0 to n and values being array values
        @param type C type of the array (char * etc...)
        @param name Name of the array in the H file
        """
        ordered_keys = list(dict.keys())
        ordered_keys.sort()
        array = [ dict[x] for x in ordered_keys ]
        self.arrays.append((array, type, name))

    def generate_header(self):
        with open(os.path.join(self.path, self.filename), 'w') as f:
            f.write("/*\n")
            f.write(f"{INDENT}THIS FILE IS AUTOGENERATED USING \"{os.path.basename(__file__)}\"\n")
            f.write(f"{INDENT}DO NOT MANUALLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING.\n")
            f.write(f"{INDENT}TO REGENERATE THIS FILE RUN THE \"{os.path.basename(__main__.__file__)}\" SCRIPT.\n")
            f.write("*/\n\n")
            f.write(f"#ifndef __{const_format(self.filename)}__\n")
            f.write(f"#define __{const_format(self.filename)}__\n")

    def generate_includes(self):
        with open(os.path.join(self.path, self.filename), 'a') as f:
            for include in self.includes:
                f.write(f"#include \"{include}\"\n")
            f.write("\n")

    def generate_enums(self):
        with open(os.path.join(self.path, self.filename), 'a') as f:
            for enum in self.enums:
                f.write(f"enum {{\n")
                for (index, item) in enumerate(enum):
                    f.write(f"{INDENT}{item} = {index},\n")
                f.write("};\n\n")

    def generate_arrays(self):
        with open(os.path.join(self.path, self.filename), 'a') as f:
            for (array, type, name) in self.arrays:
                # Figure out where to put the "// index" comment so that is aligned across the array
                # Get maximum line length
                max_line_len = len(INDENT) + len(max(array, key=len)) + 4
                # Round it to the next INDENT multiple
                comment_pos = (len(INDENT) + 1) * (max_line_len // len(INDENT))

                if type == "char *":
                    delimiter = '"'
                elif type == "char":
                    delimiter = '\''
                else:
                    delimiter = ''

                f.write(f"const {type} {name}[] = {{\n")
                for (index, item) in enumerate(array):
                    line_len = len(INDENT) + len(item) + 3
                    padding = (comment_pos - line_len) * ' '
                    f.write(f"{INDENT}{delimiter}{cleanup_string(item)}{delimiter},{padding}// {index}\n")
                f.write("};\n\n")

    def generate_footer(self):
        with open(os.path.join(self.path, self.filename), 'a') as f:
            f.write(f"#endif // __{const_format(self.filename)}__\n")

    def generate_file(self) -> None:
        self.generate_header()
        self.generate_includes()
        self.generate_enums()
        self.generate_arrays()
        self.generate_footer()
